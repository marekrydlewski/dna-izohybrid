\documentclass{article} 
\usepackage{polski}
\usepackage[utf8]{inputenc} 
\usepackage[OT4]{fontenc} 
\usepackage{graphicx,color}
\usepackage{url} 
\usepackage[pdftex,hyperfootnotes=false,pdfborder={0 0 0}]{hyperref} 
\usepackage{indentfirst}

\title{Algorytmy izotermicznego sekwencjonowania przez hybrydyzację}
%\date{October 31, 2014}%
\author{ \\ Piotr Kurzawa (117245) \\ Marek Rydlewski (117214)}

\begin{document}

\maketitle

\vspace{3ex}

\tableofcontents

\newpage

\section{Wstęp}

Celem projektu było opracowanie algorytmów izotermicznego sekwencjonowania przez hybrydyzację (ISBH). 

%Błędy negatywne - ISBH izotermiczne sekwencjonowanie (jeden rodzaj błędu)%

%0, 1, {2, 3}, {4, 5}, wiele%

Program został napisany w języku C++11 i był testowany na platformach Windows (w środowisku Visual Studio 2015) oraz OS X (z użyciem komulatora Apple LLVM w wersji 7.3.0). 

\section{Algorytm dokładny}

Algorytm ten okazał się typowym problemem grafowym - co ciekawe, mającym wiele wspólnego z znanym powszechnie \textit{problemem komiwojażera}. W związku z tym opracowanie oraz implementacja algorytmu dokładnego nie należało do wybitnie wymagających zadań w tym projekcie, gdyż podobne problemy rozwiązywaliśmy już w poprzednich latach studiów (nie mówiąc już o ogromie literatury traktującej o tego typu problemach).

Kluczową elementem tego algorytmu było wyznaczanie \textit{overlapu}, czyli długości części wspólnej dwóch dowolnych nukleotydów dostępnych w spektrum. Na podstawie tej informacji tworzyliśmy odpowiednie połączenia między dwoma nukleotydami w grafie.

Po wygenerowaniu grafu problem sprowadzał się do wyszukania optymalnej ścieżki za pomocą algorytmu przechodzenia grafu w głąb.

\subsection{Opis}

Nasze rozwiązanie dzieli się na dwa etapy: generowania grafu na podstawie spektrum oraz poszukiwanie optymalnej sekwencji nukleotydów za pomocą przeszukiwania grafu.

Na początku pierwszego etapu każdy element spektrum dodajemy do listy wierzchołków. Każdy wierzchołek zawiera wartość nukleotydu, ilość powtórzeń w spektrum oraz listę krawędzi, które wychodzą z danego wierzchołka (domyślnie jest ona pusta). Dla uproszczenia założyliśmy, że w przypadku wielokrotnego występowania danego nukleotydu nie będziemy dodawać nowego wierzchołka do grafu, a jedynie zwiększymy licznik wystąpień w wierzchołku już istniejącym. 

Następnie spośród wszystkich elementów dostępnych w spektrum generujemy pary. Dla każdej z nich uruchamiamy procedurę wyliczającą \textit{overlap} między nimi. Jeżeli istnieje jakikolwiek część wspólna między nimi, do wierzchołka źródłowego dodajemy krawędź o wadze równej wyliczonego \textit{overlapu} oraz danym wierzchołkiem docelowym. 

Drugi etap stanowi zmodyfikowaną odmianę algorytmu \textit{DFS}. Początkowo na stosie ustawiamy wierzchołek początkowy (czyli znany nam pierwszy nukleotyd w sekwencji DNA), a następnie rekurencyjnie przechodzimy po wszystkich jego sąsiadach. Fakt odwiedzin danego wierzchołka oznaczamy w tablicy \textit{visited} będącym słownikiem, którego kluczem jest wskaźnik do wierzchołka, a wartością ilość powtórzeń danego nukleotydu w spektrum. W przypadku odwiedzin dekrementujemy licznik - jeżeli osiągnie on wartość zero, uznajemy wierzchołek za już odwiedzony. 

Algorytm przeszukiwania potrafi zwrócić więcej niż jedną ścieżkę, dlatego też w tym miejscu dokonaliśmy pewnego uproszczenia i zwracaliśmy pierwszą odnalezioną sekwencję oraz przerywaliśmy rekurencję. 

\subsection{Skuteczność}

Z racji naszego uproszczenia nasz algorytm w teorii nie powinien być skuteczny w stu procentach, niemniej jednak w trakcie testów dana sekwencja okazywała się sekwencją optymalną. 

Wprowadzenie stuprocentowej skuteczności wiązałoby się z modyfikacją algorytmu przeszukiwania wszerz, co dawałoby dodatkowy narzut czasowy. 

\subsection{Złożoność}

W tym miejscu wychodzi największa wada tego algorytmu. Izotermiczne sekwencjonowanie z błędami negatywnymi (podobnie jak problem komiwojażera) należy do problemów NP-zupełnych, co mniej więcej oznacza tyle, że (nawet biorąc pod uwagę nasze uproszczenie) przy większych instancjach problemów będzie istniało zagrożenie, że ani my, ani nawet nasi potomkowie nie doczekają się wyniku. 

Dlatego też powyższy algorytm bardzo dobrze radzi sobie z mniejszymi instancjami, w przypadku których czas realizacji tego algorytmu należy jeszcze do "akceptowalnych". W przypadku większych spektrum pozostaje już tylko wyłącznie korzystanie z algorytmów przybliżonych, również ujętych w tej pracy.


\section{Algorytm przybliżony}
\subsection{Ogólne założenia}
W rozwiązaniu przybliżonym zdecydowaliśmy się na skorzystanie z algorytmu ewolucyjnego, a konkretnie z algorytmu genetycznego. Ta heurstyka znana jest ze swojej skuteczności w rozwiązywaniu wielu problemów obliczeniowo trudnych. Zdecydowaliśmy się na taki algorytm również dlatego że posiadamy doświadczenie w dość skutecznej implementacji takich heurstyk oraz znaleźliśmy w literaturze fachowej wiele przykładów na jego efektywność właśnie w problematyce sekwencjowania DNA. Ogólna idea programu jest prosta - losowana jest pewna populacja początkowa, która poddawana jest selekcji (ocenie). Najlepsze osobniki biorą udział w reprodukcji - genotypy rodziców są krzyżowane, a na otrzymanym potomstwie przeprowadzana jest mutacja, która ma za zadanie zwiększyć różnorodność i wyjść z ewentualnego optimum lokalnego. Jako wejście algorytmu przyjmujemy mapę gdzie klucze to kolejne oligonukletody w postaci stringów a wartości to odpowiednie klasy, zaimplementowane w postaci typu wyliczeniowego.
\subsection{Opis algorytmu}
Nasz algorytm został zaprojektowany do radzenie sobie z błędami negatywnymi, ale krótkie eksperymenty pokazały że radzi sobie również z problematyką sekwencjowania z błędami obu rodzajów.
Algorytm tworzy spektrum oligonukleotydów wykorzystując wejściową mapę -  do spektrum zaliczamy górną granicę danej klasy - tym sposobem gwarantujemy że nie pominiemy żadnego oligo w naszym rozwiązaniu. Jak poradziliśmy sobie z błędami negatywnymi opiszemy później (w punkcie mutacje). 
W naszym algorytmie funkcja oceny polega na skonstruowaniu wynikowego DNA stosując maksymalny overlapping przyległych oligonukleotydów w wektorze. Im więcej oligonukleotydów uda nam się zmieścić nie przekraczając długości n - długości DNA tym lepsza ocena rozwiązania. Uważny czytelnik zauważy że początkowe rozwiązania mogą przekraczać długość n co w problemie sekwencjowania z błędami negatywnymi jest dość nietypowe, jednakże taka jest natura losowych początkowych rozwiązań. Warto zwrócić uwagę, ze bardzo szybko algorytm redukuje długość rozwiązania poniżej n. Aby nie pozwolić na zbytnie skrócenie rozwiązania, zwłaszcza przy większej ilości błędów w fazie mutacji stosujemy dodanie losowych oligonukleotydów w takiej sytuacji. Finalnym rozwiązaniem jest ciąg oligonukleotydów najlepszego osobnika.
\begin{enumerate}
\item Wylosowanie populacji początkowej
\begin{itemize}
\item Osobniki to obiekty klasy, zawierające w sobie m.in wektor liczb, który określa kolejność oligonukleotydów w rozwiązaniu - liczby wskazują na poszczególne indeksy tablicy zawierającej wszystkie oligonukleotydy wejściowe
\item Losowanie polega na permutacji w oparciu o liczby pseudolosowe wykorzystując generator Mersenn'a z ziarnem które jest prawdziwą liczbą losowa
\end{itemize}
\item Ocena i wybór najlepszych osobników
\begin{itemize}
\item Wybieramy najlepsze osobniki i kierujemy je do reprodukcji, odsetek premiowanych osobników wyznaczyliśmy eksperymentalnie.
\end{itemize}
\item Krzyżowanie - wybieramy losowe pary z najlepszych rodziców. Odsetek potomków wyznaczamy doświadczalnie.
\begin{itemize}
\item Kolejne oligonukleotydy dziecka dobieramy w myśl zasady:
\begin{enumerate}
\item Wyszukujemy oligonukleotyd w obu rodzicach
\item Oceniamy overlapping między tym oligonukleotydem a następnym oligo w rodzicu
\item Porównujemy i wybieramy oligonukleotyd o większym overlappingu, w przypadku remisu wyboru dokonujemy losowo. Fakt wybrania oligo zaznaczamy w tablicy oligonukleotodyów już zużytych.
\item Jeśli oligonukleotyd nie ma następnika, lub następnik został już użyty wyszykujemy inny niewykorzystany jeszcze oligonukleotyd rodzica o jak największym overlappingu.
\end{enumerate}
\item Jak widać zastosowaliśmy tutaj krzyżowanie wielopunktowe
\end{itemize}
\item Mutacje - aby uniknąć wpadnięcia w lokalne optimum i zwiększyć przeszukiwaną przestrzeń rozwiązań stosujemy mutacje trzech rodzajów
\begin{itemize}
\item Wyszukujemy oligonukleotyd który ma najmniejszy overlapping z obu stron tj. za równo ze strony następnika jak i poprzednika. Następnie zamieniamy miejscami ten oligonukleotyd z sąsiadem - to czy zamienimy go z następnikiem czy poprzednikiem zależy który ma mniejszy swój sumaryczny overlapping (wybieramy tego gorszego). Zastosowanie takich mutacji pozwala na eliminację potencjalnych "słabych podciągów" w rozwiązaniu
\item Wybieramy dwa oligonukletody i zamieniamy je miejscami. Taki zabieg pozwala zwiększyć nam przeszukiwaną przestrzeń rozwiązań.
\item Jeśli długość rozwiązania spadła poniżej n oznacza to że wykorzystaliśmy wszystkie oligonukleotydy a niezgodność z ciągiem wejściowym będzie spowodowana obecnością błędów negatywnych. W takim wypadku zwiększamy spektrum zwiększając poziom losowego oligonukleotydu o jedną klasę.
\end{itemize}	
\item Kroki dotyczące oceny, krzyżowania oraz mutacji powtarzamy zadaną ilość razy zależną od rozmiaru spektrum również wyznaczoną eksperymentalnie.
\end{enumerate}
\subsection{Parametry algorytmu}
Wartości wyznaczyliśmy doświadczalnie, co zaprezentowaliśmy w sekcji Testy
Poszególne wartości parametrów:
\begin{itemize}
\item ilość iteracji algorytmu = (Temperatura * 2 > 50)? Temperatura * 2 : 50
\\Takie podejście pozwala nam dla dla dużych temperatur dostosować odpowiednio dużą liczbę iteracji.
\item odsetek najlepszych rodziców = ogólna liczba rodziców * 0.5
\item liczba dzieci = ogólna liczba rodziców * 0.5
\\Jak widać utrzymujemy w ten sposób stały rozmiar populacji co czyni algorytm efektywnym dla stosunkowo dużych rozmiarów instancji.
\item liczba mutacji = 0.01 * rozmiar spektrum * rozmiar populacji * 0.5
\\Podobny wzór znaleźliśmy w literaturze fachowej, bo drobnych modyfikacjach okazał idealnie się wpasowywać w nasze potrzeby.
\end{itemize}
\subsection{Skuteczność}

\subsection{Złożoność}

\section{Testy}

\section{Podsumowanie}

\end{document}

