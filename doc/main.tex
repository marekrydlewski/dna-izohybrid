\documentclass{article} 
\usepackage{polski}
\usepackage[utf8]{inputenc} 
\usepackage[OT4]{fontenc} 
\usepackage{graphicx,color}
\usepackage{url} 
\usepackage[pdftex,hyperfootnotes=false,pdfborder={0 0 0}]{hyperref} 
\usepackage{indentfirst}

\title{Algorytmy izotermicznego sekwencjonowania przez hybrydyzację}
%\date{October 31, 2014}%
\author{ \\ Piotr Kurzawa (117245) \\ Marek Rydlewski (117214)}

\begin{document}

\maketitle

\vspace{3ex}

\tableofcontents

\newpage

\section{Wstęp}

Celem projektu było opracowanie algorytmów izotermicznego sekwencjonowania przez hybrydyzację (ISBH). 

%Błędy negatywne - ISBH izotermiczne sekwencjonowanie (jeden rodzaj błędu)%

%0, 1, {2, 3}, {4, 5}, wiele%

Program został napisany w języku C++11 i był testowany na platformach Windows (w środowisku Visual Studio 2015) oraz OS X (z użyciem komulatora Apple LLVM w wersji 7.3.0). 

\section{Algorytm dokładny}

Algorytm ten okazał się typowym problemem grafowym - co ciekawe, mającym wiele wspólnego z znanym powszechnie \textit{problemem komiwojażera}. W związku z tym opracowanie oraz implementacja algorytmu dokładnego nie należało do wybitnie wymagających zadań w tym projekcie, gdyż podobne problemy rozwiązywaliśmy już w poprzednich latach studiów (nie mówiąc już o ogromie literatury traktującej o tego typu problemach).

Kluczową elementem tego algorytmu było wyznaczanie \textit{overlapu}, czyli długości części wspólnej dwóch dowolnych nukleotydów dostępnych w spektrum. Na podstawie tej informacji tworzyliśmy odpowiednie połączenia między dwoma nukleotydami w grafie.

Po wygenerowaniu grafu problem sprowadzał się do wyszukania optymalnej ścieżki za pomocą algorytmu przechodzenia grafu w głąb.

\subsection{Opis}

Nasze rozwiązanie dzieli się na dwa etapy: generowania grafu na podstawie spektrum oraz poszukiwanie optymalnej sekwencji nukleotydów za pomocą przeszukiwania grafu.

Na początku pierwszego etapu każdy element spektrum dodajemy do listy wierzchołków. Każdy wierzchołek zawiera wartość nukleotydu, ilość powtórzeń w spektrum oraz listę krawędzi, które wychodzą z danego wierzchołka (domyślnie jest ona pusta). Dla uproszczenia założyliśmy, że w przypadku wielokrotnego występowania danego nukleotydu nie będziemy dodawać nowego wierzchołka do grafu, a jedynie zwiększymy licznik wystąpień w wierzchołku już istniejącym. 

Następnie spośród wszystkich elementów dostępnych w spektrum generujemy pary. Dla każdej z nich uruchamiamy procedurę wyliczającą \textit{overlap} między nimi. Jeżeli istnieje jakikolwiek część wspólna między nimi, do wierzchołka źródłowego dodajemy krawędź o wadze równej wyliczonego \textit{overlapu} oraz danym wierzchołkiem docelowym. 

Drugi etap stanowi zmodyfikowaną odmianę algorytmu \textit{DFS}. Początkowo na stosie ustawiamy wierzchołek początkowy (czyli znany nam pierwszy nukleotyd w sekwencji DNA), a następnie rekurencyjnie przechodzimy po wszystkich jego sąsiadach. Fakt odwiedzin danego wierzchołka oznaczamy w tablicy \textit{visited} będącym słownikiem, którego kluczem jest wskaźnik do wierzchołka, a wartością ilość powtórzeń danego nukleotydu w spektrum. W przypadku odwiedzin dekrementujemy licznik - jeżeli osiągnie on wartość zero, uznajemy wierzchołek za już odwiedzony. 

Algorytm przeszukiwania potrafi zwrócić więcej niż jedną ścieżkę, dlatego też w tym miejscu dokonaliśmy pewnego uproszczenia i zwracaliśmy pierwszą odnalezioną sekwencję oraz przerywaliśmy rekurencję. 

\subsection{Skuteczność}

Z racji naszego uproszczenia nasz algorytm w teorii nie powinien być skuteczny w stu procentach, niemniej jednak w trakcie testów dana sekwencja okazywała się sekwencją optymalną. 

Wprowadzenie stuprocentowej skuteczności wiązałoby się z modyfikacją algorytmu przeszukiwania wszerz, co dawałoby dodatkowy narzut czasowy. 

\subsection{Złożoność}

W tym miejscu wychodzi największa wada tego algorytmu. Izotermiczne sekwencjonowanie z błędami negatywnymi (podobnie jak problem komiwojażera) należy do problemów NP-zupełnych, co mniej więcej oznacza tyle, że (nawet biorąc pod uwagę nasze uproszczenie) przy większych instancjach problemów będzie istniało zagrożenie, że ani my, ani nawet nasi potomkowie nie doczekają się wyniku. 

Dlatego też powyższy algorytm bardzo dobrze radzi sobie z mniejszymi instancjami, w przypadku których czas realizacji tego algorytmu należy jeszcze do "akceptowalnych". W przypadku większych spektrum pozostaje już tylko wyłącznie korzystanie z algorytmów przybliżonych, również ujętych w tej pracy.


\section{Algorytm przybliżony}

\subsection{Skuteczność}

\subsection{Złożoność}

\section{Testy}

\section{Podsumowanie}

\end{document}

